---
author: [Joseph Oforkansi, Anton Hedlund, Javier]
title: What is the performance difference, measured in time when running a doubling experiment between a SLL queue, a DLL queue and a queue built with an array based list when performing basic operations?
page-layout: full
categories: [post, queues, linked lists, doubling experiment]
date: "2025-03-28"
date-format: long
toc: true
format:
  html:
    code-links:    
      - text: Github Repository
        icon: github
        href: https://github.com/josephoforkansi/Algorithm-Analysis-All-Hands-Project-Module-2
    code-fold: true
    code-summary: "Show the code"
---

# Introduction

Efficient data structures are crucial for software performance, scalability, and responsiveness. Among these, queues are fundamental, supporting applications such as task scheduling, messaging systems, and real-time data processing. This project investigates the performance differences between three queue implementations: Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based Queue.

Our research question is: **What are the performance differences between SLL queue, DLL queue, and Array-based queue implementations when performing basic operations (e.g., `enqueue`, `dequeue`, `peek`, `__add__ (+)`, and `__iadd__ (+=)`)?**

We conducted benchmarking experiments using custom-built analysis tools to analyze these implementations. Key aspects considered include:

- **Algorithmic Complexity**: Evaluating time and space complexity to identify trade-offs.
- **Benchmarking Methodology**: Designing experiments to measure execution times and scaling behavior across varying queue sizes.

This project aims to provide insights into the efficiency of these queue implementations and guide the selection of an optimal data structure based on application requirements.

---

## Motivation

Efficient data structures are critical in real-world applications such as scheduling systems, task management, and networking. Different queue implementations offer trade-offs in performance for different operations. This project benchmarks these trade-offs to analyze execution times for fundamental queue operations and merging operations.

---

# Queue Implementations Analysis

## Queue Structure and FIFO Principle

Queues adhere to the **First-In-First-Out (FIFO)** principle, where elements are added at the rear and removed from the front, ensuring sequential processing.

## Implementations Overview

This project explores three queue implementations, located in the `analyze` directory:

1. **Singly Linked List (SLL) Queue**:
   - Implemented in `analyze/sll_queue.py` (Class: `BasicSLLQueue`).
   - Uses one-directional nodes with `next` references.
   - Maintains both `_head` and `_tail` pointers for efficient enqueue and dequeue operations.
   - Each node stores only the `data` and a `next` reference.

2. **Doubly Linked List (DLL) Queue**:
   - Implemented in `analyze/dll_queue.py` (Class: `BasicDLLQueue`).
   - Uses bidirectional nodes with both `prev` and `next` references.
   - Maintains both `_head` and `_tail` pointers for efficient operations at both ends.
   - Each node stores `data`, `prev`, and `next` references.

3. **Array-based Queue**:
   - Implemented in `analyze/ArrayQueue.py` (Class: `ArrayQueue`).
   - Uses a Python list as the underlying data structure with `front` and `rear` pointers to manage the queue.
   - Benefits from Python list's dynamic resizing capabilities.

---

## Key Operations

All implementations support the following core operations:

- **`enqueue(value)`**: Adds an element to the rear of the queue (O(1) for SLL and DLL, O(1) amortized for Array).
- **`dequeue()`**: Removes and returns the front element of the queue (O(1) for all implementations).
- **`peek()`**: Returns the front element without removing it (O(1) for all implementations).
- **`__add__(other)`**: Creates a new queue by concatenating the current queue with another queue (O(n+m) where n and m are the sizes of the queues).
- **`__iadd__(other)`**: Merges another queue into the current queue in place (O(n) for SLL and DLL, O(m) amortized for Array, where m is the size of the other queue).

### Example Implementations

#### Enqueue Operation (SLL - from `analyze/sll_queque.py`)

```python
def enqueue(self, value: Any) -> None:
    """Add an element to the end of the queue. O(1) operation using tail pointer."""
    new_node: Node = Node(value)
    if self._head is None:
        self._head = new_node
        self._tail = new_node
    else:
        self._tail.next = new_node  # Directly append at tail
        self._tail = new_node  # Update tail pointer
    self._size += 1

#### Dequeue Operation (DLL)

```python
def dequeue(self) -> Any:
    """Remove and return the first element from the queue. O(1) operation."""
    if self.is_empty():
        raise IndexError("Dequeue from empty queue")
    result: Any = self._head.data
    self._head = self._head.next
    if self._head is None:
        self._tail = None
    else:
        self._head.prev = None
    self._size -= 1
    return result
```

#### Timing Mechanism

```python
from time import perf_counter
from typing import Callable, Any

def time_operation(func: Callable[[], Any]) -> float:
    """Time an operation using high-precision counter."""
    try:
        # Warm up (optional, can be done outside)
        func()

        # Actual timing
        start_time: float = perf_counter()
        func()
        elapsed: float = perf_counter() - start_time
        return elapsed
    except Exception as e:
        print(f"Error during operation: {str(e)}") # Consider using logging
        return float("nan")
```

#### Doubling Experiment

```python
def doubling(
    initial_size: int = typer.Option(10000, help="Initial size for doubling experiment"),
    max_size: int = typer.Option(1000000, help="Maximum size for doubling experiment"),
    dll: bool = typer.Option(True, help="Test DLL implementation"),
    sll: bool = typer.Option(True, help="Test SLL implementation"),
    array: bool = typer.Option(True, help="Test Array implementation"),
) -> None:
    """Run doubling experiment on queue implementations."""
    results_dir: Path = Path("results")
    results_dir.mkdir(exist_ok=True)

    sizes: List[int] = []
    current_size: int = initial_size
    while current_size <= max_size:
        sizes.append(current_size)
        current_size *= 2

    all_results: Dict[str, Dict[str, List[float]]] = {}

    for approach, queue_class in QUEUE_IMPLEMENTATIONS.items():
        if not ((approach == "dll" and dll) or (approach == "sll" and sll) or (approach == "array" and array)):
            continue

        try:
            console.print(f"\n{approach.upper()} Queue Implementation")
            results: Dict[str, List[float]] = {
                "enqueue": [],
                "dequeue": [],
                "peek": [],
                "concat": [],
                "iconcat": [],
            }

            for size in sizes:
                queue: Any = queue_class()
                other: Any = queue_class()

                # Enqueue
                enqueue_time: float = time_operation(lambda: [queue.enqueue(i) for i in range(size)])
                results["enqueue"].append(enqueue_time)

                # Dequeue
                enqueue_half_time: float = time_operation(lambda: [queue.enqueue(i) for i in range(size // 2)]) # Ensure queue has elements
                dequeue_time: float = time_operation(lambda: [queue.dequeue() for _ in range(size // 2)])
                results["dequeue"].append(dequeue_time)
                # Refill queue (optional, for subsequent tests on similar size)
                for i in range(size // 2):
                    queue.enqueue(i)

                # Peek
                peek_time: float = time_operation(lambda: [queue.peek() for _ in range(size // 3)])
                results["peek"].append(peek_time)

                # Prepare other queue for concat
                for i in range(size // 10):
                    other.enqueue(i)

                # Concat
                concat_time: float = time_operation(lambda: queue + other)
                results["concat"].append(concat_time)

                # Iconcat
                iconcat_time: float = time_operation(lambda: queue.__iadd__(other))
                results["iconcat"].append(iconcat_time)

            # Store results for plotting
            all_results[approach] = results

            # Display results in table
            table: Table = Table(
                title=f"{approach.upper()} Queue Doubling Experiment Results",
                box=box.ROUNDED,
                show_header=True,
                header_style="bold magenta",
                width=200 # Adjusted width
            )
            table.add_column("Size (n)", justify="right", width=10)
            table.add_column("enq (ms)", justify="right", width=12)
            table.add_column("deq (ms)", justify="right", width=12)
            table.add_column("peek (ms)", justify="right", width=12)
            table.add_column("cat (ms)", justify="right", width=12)
            table.add_column("icat (ms)", justify="right", width=12)

            for i, size in enumerate(sizes):
                row: List[str] = [f"{size:,}"]
                for operation in results.keys():
                    value: float = results[operation][i]
                    if np.isnan(value):
                        row.append("N/A")
                    else:
                        row.append(f"{value * 1000:.5f}") # Show 5 decimal places
                table.add_row(*row)

            console.print(Panel(table))

        except Exception as e:
            console.print(f"[red]Error testing {approach}: {str(e)}[/red]")
            import traceback
            console.print(traceback.format_exc())
```

---

## Running and Using the Tool

Note: Link to the GitHub repository can be found on the right hand side.

The benchmarking supports three queue implementations:
- DLL (Doubly Linked List)
- SLL (Singly Linked List)
- Array-based Queue

### Setting Up

To run the benchmarking tool, ensure you have Poetry installed onto your device. Navigate to the project directory and install dependencies if you have not already:

`cd analyze && poetry install`

### Running the Experiments

The tool provides two main benchmarking experiments which can also be access by 

`poetry run analyze --help`

#### Doubling Experiment

To run the doubling experiment, execute:

`poetry run analyze doubling`

This experiment measures how performance will scale with the increasing input sizes. 

You can also run:

`poetry run analyze doubling --help`

for more details and detailed apporach

#### Implementation Performance Analysis

To analyze the performance of individual queue operations, run:

`poetry run analyze analyze`

This command will provide execution times for operations like `peek`, `dequeue`, and `enqueue` to compare their efficiency.

You can also run:

`poetry run analyze analyze --help`

for more details and detailed apporach


## Output Analysis

- Run of `systemsense` (Windows)

```bash
Displaying System Information

📋 Displaying System Panel Information ──────────────────────────────────────────────╮
┏━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ System Parameter ┃ Parameter Value                                                         ┃
┣━━━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ battery          ┃ 38.48% battery life remaining, 1:27:59 seconds remaining                ┃
┃ cpu              ┃ x86_64                                                                  ┃
┃ cpucores         ┃ Physical cores: 6, Logical cores: 12                                    ┃
┃ cpufrequencies   ┃ Min: 0.0 Mhz, Max: 0.0 Mhz                                              ┃
┃ datetime         ┃ 2025-04-29 18:16:49                                                     ┃
┃ disk             ┃ Total: 1006.85 GB, Used: 5.91 GB, Free: 949.73 GB                       ┃
┃ hostname         ┃ Ubasinachi                                                              ┃
┃ memory           ┃ Total: 3.55 GB, Available: 2.94 GB, Used: 0.43 GB                       ┃
┃ platform         ┃ Linux-5.15.167.4-microsoft-standard-WSL2-x86_64-with-glibc2.39          ┃
┃ pythonversion    ┃ 3.12.3                                                                  ┃
┃ runningprocesses ┃ 33                                                                      ┃
┃ swap             ┃ Total: 1.00 GB, Used: 0.00 GB, Free: 1.00 GB                            ┃
┃ system           ┃ Linux                                                                   ┃
┃ systemload       ┃ (0.1162109375, 0.029296875, 0.0068359375)                               ┃
┃ virtualenv       ┃ /home/oforkansi/.cache/pypoetry/virtualenvs/systemsense-Rt5TvRuf-py3.12 ┃
┗━━━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

Displaying Benchmark Results

📊 Displaying Benchmark Panel Information ──────────────────────────────╮
┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Benchmark Name ┃ Benchmark Results (sec)                                         ┃
┣━━━━━━━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃ addition       ┃ [0.33590388800075743, 0.31238813301024493, 0.31925486600084696] ┃
┃ concatenation  ┃ [1.517295183002716, 1.4222593320009764, 1.3659770480007865]     ┃
┃ exponentiation ┃ [3.8449378419900313, 2.86902611599362, 2.8711927050026134]      ┃
┃ multiplication ┃ [0.4974145239975769, 0.4764775180083234, 0.4847004899929743]    ┃
┃ rangelist      ┃ [0.1817926680087112, 0.18225304000952747, 0.19378565798979253]  ┃
┗━━━━━━━━━━━━━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛

```

#### Run of Performance Analysis

- (Windows)

```bash
DLL Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│              DLL Queue Performance Analysis                                                                                                                           │
│ ╭───────────┬───────────┬──────────┬───────────────────╮                                                                                                              │
│ │ Operation │ Time (ms) │ Elements │ Time/Element (ms) │                                                                                                              │
│ ├───────────┼───────────┼──────────┼───────────────────┤                                                                                                              │
│ │ enqueue   │  0.743459 │    1,000 │          0.000743 │                                                                                                              │
│ │ dequeue   │  0.131501 │      500 │          0.000263 │                                                                                                              │
│ │ peek      │  0.040446 │      333 │          0.000121 │                                                                                                              │
│ │ concat    │  0.991408 │      100 │          0.009914 │                                                                                                              │
│ │ iconcat   │  0.000893 │      100 │          0.000009 │                                                                                                              │
│ ╰───────────┴───────────┴──────────┴───────────────────╯                                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

SLL Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│              SLL Queue Performance Analysis                                                                                                                           │
│ ╭───────────┬───────────┬──────────┬───────────────────╮                                                                                                              │
│ │ Operation │ Time (ms) │ Elements │ Time/Element (ms) │                                                                                                              │
│ ├───────────┼───────────┼──────────┼───────────────────┤                                                                                                              │
│ │ enqueue   │  0.606404 │    1,000 │          0.000606 │                                                                                                              │
│ │ dequeue   │  0.120205 │      500 │          0.000240 │                                                                                                              │
│ │ peek      │  0.039036 │      333 │          0.000117 │                                                                                                              │
│ │ concat    │  0.996599 │      100 │          0.009966 │                                                                                                              │
│ │ iconcat   │  0.000771 │      100 │          0.000008 │                                                                                                              │
│ ╰───────────┴───────────┴──────────┴───────────────────╯                                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

ARRAY Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│             ARRAY Queue Performance Analysis                                                                                                                          │
│ ╭───────────┬───────────┬──────────┬───────────────────╮                                                                                                              │
│ │ Operation │ Time (ms) │ Elements │ Time/Element (ms) │                                                                                                              │
│ ├───────────┼───────────┼──────────┼───────────────────┤                                                                                                              │
│ │ enqueue   │  0.453412 │    1,000 │          0.000453 │                                                                                                              │
│ │ dequeue   │  0.273343 │      500 │          0.000547 │                                                                                                              │
│ │ peek      │  0.041737 │      333 │          0.000125 │                                                                                                              │
│ │ concat    │  0.423842 │      100 │          0.004238 │                                                                                                              │
│ │ iconcat   │  0.022185 │      100 │          0.000222 │                                                                                                              │
│ ╰───────────┴───────────┴──────────┴───────────────────╯                                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

#### Run of Doubling Experiment

- (Windows)

```bash
DLL Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│                   DLL Queue Doubling Experiment Results                                                                                                               │
│ ╭─────────┬───────────┬────────────┬───────────┬────────────┬───────────╮                                                                                             │
│ │    Size │   enqueue │    dequeue │           │     concat │   iconcat │                                                                                             │
│ │     (n) │      (ms) │       (ms) │ peek (ms) │       (ms) │      (ms) │                                                                                             │
│ ├─────────┼───────────┼────────────┼───────────┼────────────┼───────────┤                                                                                             │
│ │  10,000 │   6.92230 │    1.33181 │   0.41645 │   10.41418 │   0.00087 │                                                                                             │
│ │  20,000 │   9.09765 │    2.86393 │   0.82671 │   97.55136 │   0.00042 │                                                                                             │
│ │  40,000 │  35.84633 │    5.72087 │   1.59151 │   79.82920 │   0.00040 │                                                                                             │
│ │  80,000 │  97.44857 │   11.49421 │   3.53321 │  153.83688 │   0.00043 │                                                                                             │
│ │ 160,000 │ 168.93525 │   23.16861 │   6.64436 │  358.27743 │   0.00037 │                                                                                             │
│ │ 320,000 │ 455.45521 │   47.93399 │  16.06448 │  683.35232 │   0.00036 │                                                                                             │
│ │ 640,000 │ 773.40291 │   95.46572 │  27.75425 │ 1324.59378 │   0.00036 │                                                                                             │
│ ╰─────────┴───────────┴────────────┴───────────┴────────────┴───────────╯                                                                                             │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

SLL Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│                   SLL Queue Doubling Experiment Results                                                                                                               │
│ ╭─────────┬───────────┬────────────┬───────────┬────────────┬───────────╮                                                                                             │
│ │    Size │   enqueue │    dequeue │           │     concat │   iconcat │                                                                                             │
│ │     (n) │      (ms) │       (ms) │ peek (ms) │       (ms) │      (ms) │                                                                                             │
│ ├─────────┼───────────┼────────────┼───────────┼────────────┼───────────┤                                                                                             │
│ │  10,000 │   4.21128 │    0.97544 │   0.30004 │    5.32161 │   0.00070 │                                                                                             │
│ │  20,000 │  11.07327 │    2.49166 │   0.87359 │   11.17618 │   0.00039 │                                                                                             │
│ │  40,000 │  15.36752 │    4.08102 │   1.20044 │  800.30644 │   0.00037 │                                                                                             │
│ │  80,000 │  52.18054 │    7.58834 │   2.53491 │  146.01617 │   0.00038 │                                                                                             │
│ │ 160,000 │ 148.32851 │   16.70210 │   4.97924 │  264.91502 │   0.00039 │                                                                                             │
│ │ 320,000 │ 253.75014 │   31.32530 │  11.60075 │  453.10302 │   0.00038 │                                                                                             │
│ │ 640,000 │ 580.04318 │   65.34989 │  19.47487 │  713.44148 │   0.00047 │                                                                                             │
│ ╰─────────┴───────────┴────────────┴───────────┴────────────┴───────────╯                                                                                             │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

ARRAY Queue Implementation
╭───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│                  ARRAY Queue Doubling Experiment Results                                                                                                              │
│ ╭─────────┬───────────┬────────────┬───────────┬────────────┬───────────╮                                                                                             │
│ │    Size │   enqueue │    dequeue │           │     concat │   iconcat │                                                                                             │
│ │     (n) │      (ms) │       (ms) │ peek (ms) │       (ms) │      (ms) │                                                                                             │
│ ├─────────┼───────────┼────────────┼───────────┼────────────┼───────────┤                                                                                             │
│ │  10,000 │   2.55013 │    1.11667 │   0.30931 │    3.92622 │   0.20549 │                                                                                             │
│ │  20,000 │   4.84526 │    2.37176 │   0.63837 │    7.06879 │   0.43083 │                                                                                             │
│ │  40,000 │   9.87446 │    4.84830 │   1.28268 │   14.08036 │   0.86619 │                                                                                             │
│ │  80,000 │  20.05746 │    8.51486 │   2.57125 │   27.78479 │   1.77933 │                                                                                             │
│ │ 160,000 │  43.87490 │   18.49619 │   5.17515 │   56.19833 │   4.53201 │                                                                                             │
│ │ 320,000 │  84.81339 │   35.22864 │  10.38141 │  115.31138 │   6.75533 │                                                                                             │
│ │ 640,000 │ 184.07043 │   69.33369 │  20.49166 │  251.43245 │  15.58918 │                                                                                             │
│ ╰─────────┴───────────┴────────────┴───────────┴────────────┴───────────╯                                                                                             │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

#### Summary of the results

Our performance analysis reveals distinct characteristics for each queue implementation across the basic operations and concatenation:

1.  **Enqueue and Dequeue Operations:** The **Array Queue** demonstrated the most efficient performance for both `enqueue` and `dequeue` operations.
    * For `enqueue` (adding to the rear), the Array Queue was approximately 4.5 times faster than the Singly Linked List (SLL) Queue and 6 times faster than the Doubly Linked List (DLL) Queue when tested with 1,000 elements. The Array Queue completed this operation in approximately 0.45 ms.
    * Similarly, for `dequeue` (removing from the front), the Array Queue exhibited the fastest times, completing 500 dequeue operations in about 0.27 ms.

2.  **Concatenation Operations (`__add__` and `__iadd__`):** The **Linked List** implementations (both SLL and DLL) significantly outperformed the Array Queue in concatenation operations.
    * The time taken for concatenation (`__add__`) was substantially lower for both SLL and DLL Queues compared to the Array Queue. This is because linked lists can achieve concatenation by simply adjusting pointers at the tail of the first list and the head of the second, resulting in a near constant-time operation in terms of the number of elements being *linked*.
    * The in-place concatenation (`__iadd__`) also showed similar trends, with linked lists being much more efficient as they avoid the need to create a new data structure and copy elements.

3.  **Peek Operation:** The performance of the `peek` operation was consistently fast across all three implementations, with execution times in the sub-millisecond range and minimal differences observed. This is expected as `peek` involves accessing the head of the queue without modifying its structure, a constant-time operation for all three.


## Recommendations

Based on our performance analysis, we recommend the following based on the anticipated usage patterns of the queue:

### Use **Array-based Queue**:

* **Primary focus on basic operations:** When `enqueue`, `dequeue`, and `peek` are the most frequent operations, the Array Queue offers the best performance.
* **Memory efficiency considerations:** If managing memory overhead is a key concern, the contiguous nature of an array can sometimes offer better memory locality and potentially lower overhead than the node-based linked lists, especially for a large number of elements.
* **Infrequent concatenation:** If queue concatenation is a rare operation in your application, the superior performance of the Array Queue in basic operations outweighs its slower concatenation time.

### Use **DLL Queue**:

* **Frequent concatenation:** When your application requires frequent merging of queues, the DLL Queue's efficient concatenation capabilities provide a significant advantage.
* **Bidirectional traversal needs:** If there are scenarios where traversing the queue in both forward and backward directions is necessary (though not a standard queue operation), the DLL's `prev` pointers enable this.
* **Dynamic size changes and potential for operations at both ends:** While standard queues operate at the front and rear, the underlying DLL structure allows for efficient insertions or deletions at arbitrary points if the application's requirements evolve.

### Use **SLL Queue**:

* **Memory efficiency as a high priority:** SLLs have slightly less memory overhead per node compared to DLLs (as they don't need to store a `prev` pointer), making them a good choice when memory usage is a critical constraint and bidirectional traversal is not required.
* **Unidirectional traversal is sufficient:** If your application only ever needs to process the queue from front to back, the SLL's structure is adequate.
* **Frequent concatenation where memory overhead of DLL is a concern:** If concatenation is common, and the small memory saving per node in an SLL is important over the slightly more versatile DLL, then SLL is a viable option.

In summary, the choice of queue implementation should be driven by the specific operational needs and performance priorities of the application. If basic queue operations are paramount, the Array Queue is the clear winner. However, if queue merging is a frequent requirement, the Linked List implementations offer superior performance.

---

# Conclusion

Our investigation into the performance characteristics of Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based queue implementations has provided valuable insights into their trade-offs.

-   The **Array-based Queue** excels in fundamental operations like `enqueue` and `dequeue`, offering the fastest performance for these common tasks. This makes it a strong contender for applications where these operations are dominant and memory locality is beneficial.
-   The **Doubly Linked List (DLL) Queue** demonstrates its strength in operations that involve structural modifications, particularly concatenation. Its ability to efficiently merge queues makes it advantageous in scenarios where queues are frequently combined.
-   The **Singly Linked List (SLL) Queue** presents a balance, offering reasonably good performance for basic operations while maintaining a slightly lower memory footprint per element compared to the DLL. Its efficient concatenation also makes it a viable option when memory efficiency is prioritized over the added flexibility of bidirectional traversal.

Ultimately, the optimal choice of queue implementation hinges on the specific operational profile and performance requirements of the intended application.

---

# Future Work

Building upon the findings of this project, several avenues for future research and development can be explored to gain a more comprehensive understanding and potentially enhance queue implementations:

## Memory Analysis

-   **Implement detailed memory profiling:** Employ tools like `Scalene` or memory-profiler to conduct in-depth analysis of memory allocation, fragmentation, garbage collection behavior, and memory overhead associated with each queue operation across different queue sizes and operation sequences.
-   **Develop memory-optimized strategies:** Investigate and implement techniques such as memory pooling for linked list nodes to reduce allocation overhead, explore custom memory allocators for potential performance gains, and identify Python-specific optimizations to minimize memory usage.
-   **Analyze memory scaling:** Study how the memory consumption of each queue implementation scales with the number of elements and the sequence of operations performed.

## Performance Analysis

-   **Advanced benchmarking framework:** Create a more sophisticated benchmarking suite capable of:
    -   Automated performance regression testing to track performance changes over code modifications.
    -   Simulation of real-world workload patterns involving mixed sequences of enqueue, dequeue, and concatenation operations.
    -   Integration of statistical analysis tools to provide confidence intervals and more robust performance comparisons.
-   **Performance under various conditions:** Evaluate the performance of the queue implementations under:
    -   Concurrent access scenarios using threading and asynchronous programming models.
    -   Simulated distributed system environments to understand latency and throughput implications.
    -   Different hardware architectures to assess platform-specific performance characteristics.

## Implementation Innovations

-   **Hybrid data structures:** Design and evaluate hybrid queue structures that combine the strengths of arrays and linked lists, such as using array-based segments linked together, to potentially achieve better performance across a wider range of operations.
-   **Adaptive implementations:** Explore the feasibility of creating queue implementations that can dynamically adapt their underlying structure based on usage patterns to optimize for the most frequent operations.
-   **Cache-optimized designs:** Investigate strategies to improve cache utilization in linked list implementations to mitigate the performance impact of non-contiguous memory access.
-   **Extended operation sets:** Expand the functionality of the queue implementations to include:
    -   Bulk enqueue and dequeue operations for improved efficiency when processing multiple elements.
    -   Integration of priority queue features where elements are dequeued based on priority.
    -   Support for time-based operations, such as elements expiring after a certain duration.

## Research Infrastructure

-   **Comprehensive analysis tools:** Develop specialized tools for analyzing the collected performance and memory data.
-   **Interactive visualization dashboards:** Create interactive dashboards to visualize the performance and memory metrics, making it easier to identify trends and compare implementations.
-   **Automated reporting systems:** Implement systems for automatically generating reports summarizing the benchmark results and analysis.
-   **Educational resources:** Design educational materials and tools to help others understand the trade-offs between different queue implementations.

These future research directions promise to enhance our understanding of queue data structures and pave the way for more efficient and adaptable implementations tailored to diverse application needs.

# References

1.  **Documentation**
    -   [Python deque](https://docs.python.org/3/library/collections.html#collections.deque)
    -   [SLL and DLL](https://www.geeksforgeeks.org/difference-between-singly-linked-list-and-doubly-linked-list/)
    -   [Python's collections](https://realpython.com/python-collections-module/)
    -   [Linked Lists](https://cs50.harvard.edu/x/2023/notes/5/)

2.  **Books**
    -   "A First Course on Data Structures in Python"
    -   "Data Structures and Algorithm Analysis in C++" by Mark Allen Weiss
    -   "Introduction to Computation and Programming Using Python"

3.  **Course Slides**
    -   [Implementing Linked-Based Data Structures](https://algorithmology.org/slides/weeknine/#/title-slide)

## AI Contributions

Artificial intelligence tools were strategically utilized throughout this project to enhance various aspects of the research and development process. Specific contributions include:

-   **Queue Implementation Design Support**: AI models provided valuable insights and suggestions during the design phase of the Singly Linked List (SLL), Doubly Linked List (DLL), and Array-based queue implementations. This included guidance on optimizing the algorithms for core operations such as `enqueue`, `dequeue`, and concatenation to ensure efficiency and correctness.
-   **Code Optimization and Refactoring Guidance**: AI-powered code analysis tools offered recommendations for improving the performance and maintainability of the codebase. For instance, suggestions were provided to refine the `time_operation` function for more accurate benchmarking and to streamline code within queue operation methods, reducing redundancy and enhancing readability.
-   **Benchmarking Experiment Design Assistance**: AI assisted in the conceptualization and refinement of the benchmarking experiments, including the doubling experiment methodology and the initial performance analysis scripts. This support helped ensure that the experimental design was robust and capable of effectively capturing the performance distinctions between the different queue implementations.

It is important to note that all AI-generated suggestions and contributions were rigorously reviewed, validated, and integrated by the project team members to ensure accuracy, relevance, and alignment with the project's objectives and standards.
